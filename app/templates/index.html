{% extends "base.html" %}
{% from 'macros/cpu_widget.html' import cpu_widget %}
{% from 'macros/memory_widget.html' import memory_widget %}
{% from 'macros/network_widget.html' import network_widget %}
{% from 'macros/disk_widget.html' import disk_widget %}
{% from 'macros/io_widget.html' import io_widget %}

{% block title %}Dashboard - System Monitor{% endblock %}

{% block extra_css %}
<link href="https://cdn.jsdelivr.net/npm/gridstack@7.2.3/dist/gridstack.min.css" rel="stylesheet" />
<style>
    .grid-stack {
        background: rgba(255, 255, 255, 0.02);
        border-radius: 1rem;
        min-height: 80vh;
    }

    .grid-stack-item-content {
        overflow: hidden !important;
    }

    .widget {
        height: 100%;
        width: 100%;
        display: flex;
        flex-direction: column;
    }

    .dashboard-actions {
        display: flex;
        gap: 1rem;
        margin-left: auto;
    }

    .grid-stack-item.ui-draggable-dragging {
        opacity: 0.8;
        z-index: 1000;
    }
</style>
{% endblock %}

{% block content %}
<div class="container">
    <header>
        <h1>System Monitor Dashboard</h1>
        <div style="display: flex; gap: 1rem; align-items: center; width: 100%;">
            {% if servers|length > 1 %}
            <select id="serverSelect"
                style="padding: 0.5rem 1rem; border-radius: 0.375rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); color: var(--text-primary);">
                {% for server in servers %}
                <option value="{{ server.id }}">{{ server.name }}</option>
                {% endfor %}
            </select>
            {% endif %}

            <div class="status-indicator">
                <span class="dot"></span> Live
            </div>

            <div id="datetime-display" class="datetime-dashboard"></div>

            <div class="dashboard-actions">
                <button class="btn btn-secondary btn-sm" onclick="resetLayout()">
                    <i class="fas fa-undo"></i> Reset Layout
                </button>
                <button class="btn btn-primary btn-sm" onclick="saveLayout()">
                    <i class="fas fa-save"></i> Save Layout
                </button>
            </div>
        </div>
    </header>

    <div class="grid-stack">
        <!-- Widgets will be injected here by Gridstack -->
    </div>

    <!-- CPU Details Modal -->
    <div id="cpu-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="cpu-modal-title">Top CPU Processes</h2>
                <div class="modal-controls">
                    <button class="modal-btn" onclick="toggleMinimize('cpu-modal')"><i
                            class="fas fa-minus"></i></button>
                    <button class="modal-btn" onclick="toggleMaximize('cpu-modal')"><i
                            class="far fa-square"></i></button>
                    <button class="modal-close" onclick="closeCPUModal()">&times;</button>
                </div>
            </div>
            <div class="modal-body">
                <table class="connection-table">
                    <thead>
                        <tr>
                            <th>Process</th>
                            <th>PID</th>
                            <th>User</th>
                            <th>CPU %</th>
                            <th>Memory %</th>
                        </tr>
                    </thead>
                    <tbody id="cpu-table-body">
                        <!-- Rows inserted here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Memory Details Modal -->
    <div id="memory-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="memory-modal-title">Top Memory Processes</h2>
                <div class="modal-controls">
                    <button class="modal-btn" onclick="toggleMinimize('memory-modal')"><i
                            class="fas fa-minus"></i></button>
                    <button class="modal-btn" onclick="toggleMaximize('memory-modal')"><i
                            class="far fa-square"></i></button>
                    <button class="modal-close" onclick="closeMemoryModal()">&times;</button>
                </div>
            </div>
            <div class="modal-body">
                <table class="connection-table">
                    <thead>
                        <tr>
                            <th>Process</th>
                            <th>PID</th>
                            <th>User</th>
                            <th>Memory %</th>
                            <th>CPU %</th>
                        </tr>
                    </thead>
                    <tbody id="memory-table-body">
                        <!-- Rows inserted here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Network Connections Modal -->
    <div id="connection-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="connection-modal-title">Network Connections</h2>
                <div class="modal-controls">
                    <button class="modal-btn" onclick="toggleMinimize('connection-modal')"><i
                            class="fas fa-minus"></i></button>
                    <button class="modal-btn" onclick="toggleMaximize('connection-modal')"><i
                            class="far fa-square"></i></button>
                    <button class="modal-close" onclick="closeConnectionModal()">&times;</button>
                </div>
            </div>
            <div class="modal-body">
                <table class="connection-table">
                    <thead>
                        <tr>
                            <th>Protocol</th>
                            <th>Local Address</th>
                            <th>Remote Address</th>
                            <th>Status</th>
                            <th>PID</th>
                            <th>Process</th>
                        </tr>
                    </thead>
                    <tbody id="connection-table-body">
                        <!-- Connection rows will be inserted here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Disk I/O Read Process Modal -->
    <div id="io-read-modal" class="modal">
        <div class="modal-content" style="top: 150px; left: 150px;">
            <div class="modal-header">
                <h2 id="io-read-modal-title">Disk I/O (Read)</h2>
                <div class="modal-controls">
                    <button class="modal-btn" onclick="toggleMinimize('io-read-modal')"><i
                            class="fas fa-minus"></i></button>
                    <button class="modal-btn" onclick="toggleMaximize('io-read-modal')"><i
                            class="far fa-square"></i></button>
                    <button class="modal-close" onclick="closeIOReadModal()">&times;</button>
                </div>
            </div>
            <div class="modal-body">
                <div class="table-responsive">
                    <table class="connection-table">
                        <thead>
                            <tr>
                                <th>Process</th>
                                <th>PID</th>
                                <th>Read Bytes</th>
                                <th>Read Ops</th>
                            </tr>
                        </thead>
                        <tbody id="io-read-table-body">
                            <!-- Process rows will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Disk I/O Write Process Modal -->
    <div id="io-write-modal" class="modal">
        <div class="modal-content" style="top: 200px; left: 200px;">
            <div class="modal-header">
                <h2 id="io-write-modal-title">Disk I/O (Write)</h2>
                <div class="modal-controls">
                    <button class="modal-btn" onclick="toggleMinimize('io-write-modal')"><i
                            class="fas fa-minus"></i></button>
                    <button class="modal-btn" onclick="toggleMaximize('io-write-modal')"><i
                            class="far fa-square"></i></button>
                    <button class="modal-close" onclick="closeIOWriteModal()">&times;</button>
                </div>
            </div>
            <div class="modal-body">
                <div class="table-responsive">
                    <table class="connection-table">
                        <thead>
                            <tr>
                                <th>Process</th>
                                <th>PID</th>
                                <th>Write Bytes</th>
                                <th>Write Ops</th>
                            </tr>
                        </thead>
                        <tbody id="io-write-table-body">
                            <!-- Process rows will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Disk Analysis Modal -->
    <div id="disk-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="disk-modal-title">Disk Analysis</h2>
                <div class="modal-controls">
                    <button class="modal-btn" onclick="toggleMinimize('disk-modal')"><i
                            class="fas fa-minus"></i></button>
                    <button class="modal-btn" onclick="toggleMaximize('disk-modal')"><i
                            class="far fa-square"></i></button>
                    <button class="modal-close" onclick="closeDiskModal()">&times;</button>
                </div>
            </div>
            <div class="modal-body">
                <div id="disk-loading" style="text-align: center; padding: 2rem; display: none;">
                    <div class="spinner"></div>
                    <p>Analyzing disk usage... This may take a moment.</p>
                </div>
                <div id="disk-analysis-content">
                    <h4 style="margin-bottom: 1rem; color: var(--text-secondary);">Top Directories</h4>
                    <div id="directory-list" class="directory-list">
                        <!-- Directory items will be inserted here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

</div>

<div id="config-data" data-refresh-interval="{{ preferences.refresh_interval if preferences else 2000 }}"
    data-max-data-points="{{ preferences.chart_data_points if preferences else 60 }}"
    data-server-id="{{ servers[0].id if servers else '' }}" style="display: none;">
</div>

<!-- Hidden widget templates for Gridstack to use -->
<div id="widget-templates" style="display: none;">
    <div id="tpl-cpu">{{ cpu_widget('cpu-widget') }}</div>
    <div id="tpl-memory">{{ memory_widget('memory-widget') }}</div>
    <div id="tpl-network">{{ network_widget('network-widget') }}</div>
    <div id="tpl-io">{{ io_widget('io-widget') }}</div>
    <div id="tpl-disk">{{ disk_widget('disk-widget') }}</div>
</div>

{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/gridstack@7.2.3/dist/gridstack-all.js"></script>
<script>
    // Configuration from data attributes
    const configData = document.getElementById('config-data');
    const refreshInterval = parseInt(configData.dataset.refreshInterval) || 2000;
    const maxDataPoints = parseInt(configData.dataset.maxDataPoints) || 60;
    let currentServerId = configData.dataset.serverId ? parseInt(configData.dataset.serverId) : null;

    // Chart data storage
    const cpuData = [];
    const memoryData = [];
    const networkData = [];
    const labels = [];

    let grid = null;
    let cpuChart = null;
    let memoryChart = null;
    let networkChart = null;
    // Default layout configuration
    const defaultLayout = [
        { x: 0, y: 0, w: 4, h: 4, id: 'cpu', content: document.getElementById('tpl-cpu').innerHTML },
        { x: 4, y: 0, w: 4, h: 4, id: 'memory', content: document.getElementById('tpl-memory').innerHTML },
        { x: 8, y: 0, w: 4, h: 4, id: 'network', content: document.getElementById('tpl-network').innerHTML },
        { x: 0, y: 4, w: 6, h: 4, id: 'io', content: document.getElementById('tpl-io').innerHTML },
        { x: 6, y: 4, w: 6, h: 4, id: 'disk', content: document.getElementById('tpl-disk').innerHTML }
    ];

    document.addEventListener('DOMContentLoaded', async function () {
        // Initialize Gridstack
        grid = GridStack.init({
            column: 12,
            cellHeight: 100,
            margin: 10,
            animate: true,
            float: true
        });

        // Load saved layout or use default
        await loadLayout();

        // Initialize charts after widgets are in DOM
        initCharts();

        // Start updates
        updateMetrics();
        setInterval(updateMetrics, refreshInterval);
    });

    async function loadLayout() {
        try {
            const response = await fetch('/api/dashboard/layout');
            const data = await response.json();

            let layout = defaultLayout;

            if (data.layout_config) {
                // Merge saved config with content templates
                layout = data.layout_config.map(item => {
                    const tplId = `tpl-${item.id}`;
                    const tpl = document.getElementById(tplId);
                    return {
                        ...item,
                        content: tpl ? tpl.innerHTML : ''
                    };
                });
            }

            grid.load(layout);

        } catch (error) {
            console.error('Error loading layout:', error);
            grid.load(defaultLayout);
        }
    }

    async function saveLayout() {
        const layout = grid.save(false); // false = don't save content, just structure
        // Map back to simple IDs for storage
        const simplifiedLayout = layout.map(item => ({
            x: item.x,
            y: item.y,
            w: item.w,
            h: item.h,
            id: item.id || item.el.querySelector('.widget').dataset.widgetType
        }));

        try {
            const response = await fetch('/api/dashboard/layout', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: 'My Layout',
                    layout_config: simplifiedLayout
                })
            });

            if (response.ok) {
                // Show success feedback
                const btn = document.querySelector('button[onclick="saveLayout()"]');
                const originalText = btn.innerHTML;
                btn.innerHTML = '<i class="fas fa-check"></i> Saved!';
                setTimeout(() => btn.innerHTML = originalText, 2000);
            }
        } catch (error) {
            console.error('Error saving layout:', error);
            alert('Failed to save layout');
        }
    }

    function resetLayout() {
        if (confirm('Reset to default layout?')) {
            grid.removeAll();
            grid.load(defaultLayout);
            // Re-init charts as DOM elements were recreated
            setTimeout(initCharts, 100);
        }
    }

    function initCharts() {
        // CPU Chart
        const cpuCanvas = document.getElementById('cpu-widget-chart');
        if (cpuCanvas) {
            if (cpuChart) cpuChart.destroy();
            cpuChart = new Chart(cpuCanvas, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'CPU %',
                        data: cpuData,
                        borderColor: 'rgba(56, 189, 248, 1)',
                        backgroundColor: 'rgba(56, 189, 248, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { beginAtZero: true, max: 100, ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                        x: { display: false }
                    }
                }
            });
        }
        // Memory Chart
        const memCanvas = document.getElementById('memory-widget-chart');
        if (memCanvas) {
            if (memoryChart) memoryChart.destroy();
            memoryChart = new Chart(memCanvas, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Memory %',
                        data: memoryData,
                        borderColor: 'rgba(168, 85, 247, 1)',
                        backgroundColor: 'rgba(168, 85, 247, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { beginAtZero: true, max: 100, ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                        x: { display: false }
                    }
                }
            });
        }
        // Network Chart
        const netCanvas = document.getElementById('network-widget-chart');
        if (netCanvas) {
            if (networkChart) networkChart.destroy();
            networkChart = new Chart(netCanvas, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Network Sent (bytes)',
                        data: networkData,
                        borderColor: 'rgba(255, 99, 132, 1)',
                        backgroundColor: 'rgba(255, 99, 132, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { beginAtZero: true, ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                        x: { display: false }
                    }
                }
            });
        }

    }

    // Server selection
    const serverSelect = document.getElementById('serverSelect');
    if (serverSelect) {
        serverSelect.addEventListener('change', (e) => {
            currentServerId = parseInt(e.target.value);
            updateMetrics();
        });
    }

    // Fetch and update metrics
    async function updateMetrics() {
        try {
            const url = currentServerId ? `/api/metrics?server_id=${currentServerId}` : '/api/metrics';
            const response = await fetch(url);
            const data = await response.json();

            // Update CPU
            updateText('cpu-widget-percent', data.cpu.percent.toFixed(1));
            updateText('cpu-widget-freq', data.cpu.freq);
            if (data.cpu.temp_c) {
                updateText('cpu-widget-temp', `${data.cpu.temp_c.toFixed(1)}°C / ${data.cpu.temp_f.toFixed(1)}°F`);
            }

            // Update Memory
            updateText('memory-widget-percent', data.memory.percent.toFixed(1));
            updateText('memory-widget-used', data.memory.used);
            updateText('memory-widget-total', data.memory.total);

            // Update Network
            if (data.network) {
                updateText('network-widget-sent', data.network.bytes_sent);
                updateText('network-widget-recv', data.network.bytes_recv);
                // Push to network chart data
                networkData.push(data.network.bytes_sent_raw);
            }
            if (data.connections) {
                updateText('network-widget-connections', data.connections.total);
                updateText('network-widget-established', data.connections.established);
            }

            // Update Disk I/O
            updateText('io-widget-read', data.io.read_bytes);
            updateText('io-widget-write', data.io.write_bytes);
            updateText('io-widget-read-count', `${data.io.read_count.toLocaleString()} ops`);
            updateText('io-widget-write-count', `${data.io.write_count.toLocaleString()} ops`);

            // Update Disk Usage
            const diskList = document.getElementById('disk-widget-list');
            if (diskList) {
                diskList.innerHTML = '';
                data.disk.forEach(disk => {
                    const diskItem = document.createElement('div');
                    diskItem.className = 'disk-item clickable-disk-item';
                    diskItem.onclick = () => showDiskAnalysis(disk.mountpoint);
                    diskItem.title = 'Click to analyze disk space usage';
                    diskItem.innerHTML = `
                        <div class="disk-header">
                            <span><strong>${disk.device}</strong> (${disk.mountpoint})</span>
                            <span>${disk.used} / ${disk.total} (${disk.percent.toFixed(1)}%)</span>
                        </div>
                        <div class="disk-bar-bg">
                            <div class="disk-bar-fill" style="width: ${disk.percent}%"></div>
                        </div>
                    `;
                    diskList.appendChild(diskItem);
                });
            }

            // Update charts
            const now = new Date().toLocaleTimeString();
            labels.push(now);
            cpuData.push(data.cpu.percent);
            memoryData.push(data.memory.percent);

            if (labels.length > maxDataPoints) {
                labels.shift();
                cpuData.shift();
                memoryData.shift();
                networkData.shift();
            }

            if (cpuChart) cpuChart.update('none');
            if (memoryChart) memoryChart.update('none');
            if (networkChart) networkChart.update('none');
        } catch (error) {
            console.error('Error fetching metrics:', error);
        }
    }

    function updateText(id, value) {
        const el = document.getElementById(id);
        if (el) el.textContent = value;
    }

    // Network Connection Details Modal
    async function showConnectionDetails(status) {
        try {
            const url = status === 'all'
                ? '/api/network/connections'
                : `/api/network/connections?status=${status}`;

            const response = await fetch(url);
            const data = await response.json();

            if (data.error) {
                alert(`Error: ${data.error}`);
                return;
            }

            // Populate modal with connection data
            const tableBody = document.getElementById('connection-table-body');
            tableBody.innerHTML = '';

            if (data.connections.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: var(--text-secondary);">No connections found</td></tr>';
            } else {
                data.connections.forEach(conn => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${conn.protocol}</td>
                        <td>${conn.local_address}</td>
                        <td>${conn.remote_address}</td>
                        <td><span class="status-badge status-${conn.status.toLowerCase()}">${conn.status}</span></td>
                        <td>${conn.pid}</td>
                        <td>${conn.process}</td>
                    `;
                    tableBody.appendChild(row);
                });
            }

            // Update modal title
            const modalTitle = document.getElementById('connection-modal-title');
            modalTitle.textContent = status === 'all'
                ? `All Network Connections (${data.count})`
                : `Established Connections (${data.count})`;

            // Show modal
            const modal = document.getElementById('connection-modal');
            modal.style.display = 'flex';
            bringToFront('connection-modal');
        } catch (error) {
            console.error('Error fetching connection details:', error);
            alert('Failed to fetch connection details');
        }
    }

    function closeConnectionModal() {
        document.getElementById('connection-modal').style.display = 'none';
    }

    // CPU Details
    async function showCPUDetails() {
        const modal = document.getElementById('cpu-modal');
        const tbody = document.getElementById('cpu-table-body');

        modal.style.display = 'block';
        bringToFront('cpu-modal');
        tbody.innerHTML = '<tr><td colspan="5" style="text-align: center;">Loading...</td></tr>';

        try {
            const response = await fetch('/api/processes?sort=cpu');
            const data = await response.json();

            tbody.innerHTML = '';

            if (data.processes && data.processes.length > 0) {
                // Take top 20
                data.processes.slice(0, 20).forEach(proc => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td><span class="process-name">${proc.name}</span></td>
                        <td>${proc.pid}</td>
                        <td>${proc.username}</td>
                        <td>${proc.cpu_percent.toFixed(1)}%</td>
                        <td>${proc.memory_percent.toFixed(1)}%</td>
                    `;
                    tbody.appendChild(row);
                });
            } else {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center;">No processes found</td></tr>';
            }
        } catch (error) {
            console.error('Error fetching CPU details:', error);
            tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: var(--danger);">Error loading data</td></tr>';
        }
    }

    function closeCPUModal() {
        document.getElementById('cpu-modal').style.display = 'none';
    }

    // Memory Details
    async function showMemoryDetails() {
        const modal = document.getElementById('memory-modal');
        const tbody = document.getElementById('memory-table-body');

        modal.style.display = 'block';
        bringToFront('memory-modal');
        tbody.innerHTML = '<tr><td colspan="5" style="text-align: center;">Loading...</td></tr>';

        try {
            const response = await fetch('/api/processes?sort=memory');
            const data = await response.json();

            tbody.innerHTML = '';

            if (data.processes && data.processes.length > 0) {
                // Take top 20
                data.processes.slice(0, 20).forEach(proc => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td><span class="process-name">${proc.name}</span></td>
                        <td>${proc.pid}</td>
                        <td>${proc.username}</td>
                        <td>${proc.memory_percent.toFixed(1)}%</td>
                        <td>${proc.cpu_percent.toFixed(1)}%</td>
                    `;
                    tbody.appendChild(row);
                });
            } else {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center;">No processes found</td></tr>';
            }
        } catch (error) {
            console.error('Error fetching Memory details:', error);
            tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: var(--danger);">Error loading data</td></tr>';
        }
    }

    function closeMemoryModal() {
        document.getElementById('memory-modal').style.display = 'none';
    }

    // Close modal when clicking outside - REMOVED for modeless windows
    // Windows are now closed via the close button only
    /*
    window.onclick = function (event) {
        const modal = document.getElementById('connection-modal');
        if (event.target == modal) {
            closeConnectionModal();
        }
        // ... other modals
    }
    */

    // Disk I/O Process Details
    async function showIOReadProcessDetails() {
        const modal = document.getElementById('io-read-modal');
        const tbody = document.getElementById('io-read-table-body');

        // Show modal immediately
        modal.style.display = 'block';
        bringToFront('io-read-modal');
        tbody.innerHTML = '<tr><td colspan="4" style="text-align: center;">Loading...</td></tr>';

        try {
            const response = await fetch('/api/disk/io-processes?sort=read');
            const data = await response.json();

            tbody.innerHTML = '';

            if (data.processes && data.processes.length > 0) {
                data.processes.forEach(proc => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td><span class="process-name">${proc.name}</span></td>
                        <td>${proc.pid}</td>
                        <td>${proc.read_bytes_formatted}</td>
                        <td>${proc.read_count}</td>
                    `;
                    tbody.appendChild(row);
                });
            } else {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align: center;">No active read processes found</td></tr>';
            }
        } catch (error) {
            console.error('Error fetching I/O details:', error);
            tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--danger);">Error loading data</td></tr>';
        }
    }

    async function showIOWriteProcessDetails() {
        const modal = document.getElementById('io-write-modal');
        const tbody = document.getElementById('io-write-table-body');

        // Show modal immediately
        modal.style.display = 'block';
        bringToFront('io-write-modal');
        tbody.innerHTML = '<tr><td colspan="4" style="text-align: center;">Loading...</td></tr>';

        try {
            const response = await fetch('/api/disk/io-processes?sort=write');
            const data = await response.json();

            tbody.innerHTML = '';

            if (data.processes && data.processes.length > 0) {
                data.processes.forEach(proc => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td><span class="process-name">${proc.name}</span></td>
                        <td>${proc.pid}</td>
                        <td>${proc.write_bytes_formatted}</td>
                        <td>${proc.write_count}</td>
                    `;
                    tbody.appendChild(row);
                });
            } else {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align: center;">No active write processes found</td></tr>';
            }
        } catch (error) {
            console.error('Error fetching I/O details:', error);
            tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--danger);">Error loading data</td></tr>';
        }
    }

    function closeIOReadModal() {
        document.getElementById('io-read-modal').style.display = 'none';
    }

    function closeIOWriteModal() {
        document.getElementById('io-write-modal').style.display = 'none';
    }

    // Disk Analysis
    async function showDiskAnalysis(mountpoint) {
        const modal = document.getElementById('disk-modal');
        const loading = document.getElementById('disk-loading');
        const content = document.getElementById('disk-analysis-content');
        const list = document.getElementById('directory-list');
        const title = document.getElementById('disk-modal-title');

        title.textContent = `Disk Analysis: ${mountpoint}`;
        modal.style.display = 'block';
        bringToFront('disk-modal');
        loading.style.display = 'block';
        content.style.display = 'none';
        list.innerHTML = '';

        try {
            const response = await fetch(`/api/disk/analyze?mountpoint=${encodeURIComponent(mountpoint)}`);
            const data = await response.json();

            loading.style.display = 'none';
            content.style.display = 'block';

            if (data.directories && data.directories.length > 0) {
                // Find max size for progress bars
                const maxSize = data.directories[0].size;

                data.directories.forEach(dir => {
                    const percent = (dir.size / maxSize) * 100;
                    const item = document.createElement('div');
                    item.className = 'directory-item';
                    item.innerHTML = `
                        <div class="directory-info">
                            <span class="directory-path" title="${dir.path}">${dir.path}</span>
                            <span class="directory-size">${dir.size_formatted}</span>
                        </div>
                        <div class="directory-bar-bg">
                            <div class="directory-bar-fill" style="width: ${percent}%"></div>
                        </div>
                        <div class="directory-meta">
                            ${dir.file_count.toLocaleString()} files
                        </div>
                    `;
                    list.appendChild(item);
                });
            } else {
                list.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">No directories found or permission denied</p>';
            }
        } catch (error) {
            console.error('Error analyzing disk:', error);
            loading.style.display = 'none';
            content.style.display = 'block';
            list.innerHTML = '<p style="text-align: center; color: var(--danger);">Error analyzing disk usage</p>';
        }
    }

    function closeDiskModal() {
        document.getElementById('disk-modal').style.display = 'none';
    }

    // Modal State Management (Maximize/Minimize)
    const modalStates = {};

    function toggleMaximize(modalId) {
        const modal = document.getElementById(modalId);
        const content = modal.querySelector('.modal-content');
        const icon = modal.querySelector('button[onclick^="toggleMaximize"] i');

        if (content.classList.contains('maximized')) {
            // Restore
            content.classList.remove('maximized');
            icon.classList.remove('fa-window-restore');
            icon.classList.add('fa-square');
            icon.classList.add('far'); // Regular square
            icon.classList.remove('fas'); // Solid restore icon

            // Restore position/size if interact.js modified it, or let CSS handle it
            // For simplicity, we rely on removing the class to revert to CSS defaults or previous interact state
            // However, interact.js sets inline styles. We might need to clear them or restore them.
            // A simple approach: clear inline styles related to size/pos when maximizing, restore them when un-maximizing?
            // Better: Just toggle the class. The class should use !important to override inline styles.
        } else {
            // Maximize
            content.classList.remove('minimized'); // Ensure not minimized
            content.classList.add('maximized');
            icon.classList.remove('fa-square');
            icon.classList.remove('far');
            icon.classList.add('fa-window-restore');
            icon.classList.add('fas');
        }
        bringToFront(modalId);
    }

    function toggleMinimize(modalId) {
        const modal = document.getElementById(modalId);
        const content = modal.querySelector('.modal-content');

        if (content.classList.contains('minimized')) {
            // Restore
            content.classList.remove('minimized');
            bringToFront(modalId);
        } else {
            // Minimize
            content.classList.remove('maximized'); // Ensure not maximized
            content.classList.add('minimized');
        }
    }

    // Z-Index Management for Multi-Window Support
    let highestZIndex = 2000;

    function bringToFront(modalId) {
        const modal = document.getElementById(modalId);
        // We need to target the .modal-content since the .modal wrapper has pointer-events: none
        // But wait, the .modal wrapper is what we usually toggle display on.
        // Actually, for modeless, we might want to apply z-index to the wrapper if they are separate wrappers?
        // In this app, each modal has its own wrapper: <div id="connection-modal" class="modal">...</div>
        // So we should increase z-index of the wrapper?
        // BUT, the wrapper is fixed full screen with pointer-events: none.
        // The content is what matters.
        // Let's check style.css: .modal { z-index: 2000; }
        // If we have multiple .modal wrappers, they stack.
        // If we want them to reorder, we must change z-index of the .modal wrapper.

        highestZIndex++;
        modal.style.zIndex = highestZIndex;

        // Visual Distinction: Remove active class from all, add to current
        document.querySelectorAll('.modal-content').forEach(el => {
            el.classList.remove('active');
        });

        const content = modal.querySelector('.modal-content');
        if (content) {
            content.classList.add('active');
        }
    }

    // Add mousedown listeners to all modal contents to bring to front on click
    document.addEventListener('DOMContentLoaded', () => {
        const modals = document.querySelectorAll('.modal');
        modals.forEach(modal => {
            const content = modal.querySelector('.modal-content');
            if (content) {
                content.addEventListener('mousedown', () => {
                    bringToFront(modal.id);
                });
            }
        });
    });

</script>
{% endblock %}