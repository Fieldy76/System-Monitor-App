{% extends "base.html" %}
{% from 'macros/cpu_widget.html' import cpu_widget %}
{% from 'macros/memory_widget.html' import memory_widget %}
{% from 'macros/network_widget.html' import network_widget %}
{% from 'macros/disk_widget.html' import disk_widget %}
{% from 'macros/io_widget.html' import io_widget %}

{% block title %}Dashboard - System Monitor{% endblock %}

{% block extra_css %}
<link href="https://cdn.jsdelivr.net/npm/gridstack@7.2.3/dist/gridstack.min.css" rel="stylesheet" />
<style>
    .grid-stack {
        background: rgba(255, 255, 255, 0.02);
        border-radius: 1rem;
        min-height: 80vh;
    }

    .grid-stack-item-content {
        overflow: hidden !important;
    }

    .widget {
        height: 100%;
        width: 100%;
        display: flex;
        flex-direction: column;
    }

    .dashboard-actions {
        display: flex;
        gap: 1rem;
        margin-left: auto;
    }

    .grid-stack-item.ui-draggable-dragging {
        opacity: 0.8;
        z-index: 1000;
    }
</style>
{% endblock %}

{% block content %}
<div class="container">
    <header>
        <h1>System Monitor Dashboard</h1>
        <div style="display: flex; gap: 1rem; align-items: center; width: 100%;">
            {% if servers|length > 1 %}
            <select id="serverSelect"
                style="padding: 0.5rem 1rem; border-radius: 0.375rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); color: var(--text-primary);">
                {% for server in servers %}
                <option value="{{ server.id }}">{{ server.name }}</option>
                {% endfor %}
            </select>
            {% endif %}

            <div class="status-indicator">
                <span class="dot"></span> Live
            </div>

            <div class="dashboard-actions">
                <button class="btn btn-secondary btn-sm" onclick="resetLayout()">
                    <i class="fas fa-undo"></i> Reset Layout
                </button>
                <button class="btn btn-primary btn-sm" onclick="saveLayout()">
                    <i class="fas fa-save"></i> Save Layout
                </button>
            </div>
        </div>
    </header>

    <div class="grid-stack">
        <!-- Widgets will be injected here by Gridstack -->
    </div>

    <!-- Network Connections Modal -->
    <div id="connection-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="connection-modal-title">Network Connections</h2>
                <button class="modal-close" onclick="closeConnectionModal()">&times;</button>
            </div>
            <div class="modal-body">
                <table class="connection-table">
                    <thead>
                        <tr>
                            <th>Protocol</th>
                            <th>Local Address</th>
                            <th>Remote Address</th>
                            <th>Status</th>
                            <th>PID</th>
                            <th>Process</th>
                        </tr>
                    </thead>
                    <tbody id="connection-table-body">
                        <!-- Connection rows will be inserted here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

</div>

<div id="config-data" data-refresh-interval="{{ preferences.refresh_interval if preferences else 2000 }}"
    data-max-data-points="{{ preferences.chart_data_points if preferences else 60 }}"
    data-server-id="{{ servers[0].id if servers else '' }}" style="display: none;">
</div>

<!-- Hidden widget templates for Gridstack to use -->
<div id="widget-templates" style="display: none;">
    <div id="tpl-cpu">{{ cpu_widget('cpu-widget') }}</div>
    <div id="tpl-memory">{{ memory_widget('memory-widget') }}</div>
    <div id="tpl-network">{{ network_widget('network-widget') }}</div>
    <div id="tpl-io">{{ io_widget('io-widget') }}</div>
    <div id="tpl-disk">{{ disk_widget('disk-widget') }}</div>
</div>

{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/gridstack@7.2.3/dist/gridstack-all.js"></script>
<script>
    // Configuration from data attributes
    const configData = document.getElementById('config-data');
    const refreshInterval = parseInt(configData.dataset.refreshInterval) || 2000;
    const maxDataPoints = parseInt(configData.dataset.maxDataPoints) || 60;
    let currentServerId = configData.dataset.serverId ? parseInt(configData.dataset.serverId) : null;

    // Chart data storage
    const cpuData = [];
    const memoryData = [];
    const networkData = [];
    const labels = [];

    let grid = null;
    let cpuChart = null;
    let memoryChart = null;
    let networkChart = null;
    // Default layout configuration
    const defaultLayout = [
        { x: 0, y: 0, w: 4, h: 4, id: 'cpu', content: document.getElementById('tpl-cpu').innerHTML },
        { x: 4, y: 0, w: 4, h: 4, id: 'memory', content: document.getElementById('tpl-memory').innerHTML },
        { x: 8, y: 0, w: 4, h: 4, id: 'network', content: document.getElementById('tpl-network').innerHTML },
        { x: 0, y: 4, w: 6, h: 4, id: 'io', content: document.getElementById('tpl-io').innerHTML },
        { x: 6, y: 4, w: 6, h: 4, id: 'disk', content: document.getElementById('tpl-disk').innerHTML }
    ];

    document.addEventListener('DOMContentLoaded', async function () {
        // Initialize Gridstack
        grid = GridStack.init({
            column: 12,
            cellHeight: 100,
            margin: 10,
            animate: true,
            float: true
        });

        // Load saved layout or use default
        await loadLayout();

        // Initialize charts after widgets are in DOM
        initCharts();

        // Start updates
        updateMetrics();
        setInterval(updateMetrics, refreshInterval);
    });

    async function loadLayout() {
        try {
            const response = await fetch('/api/dashboard/layout');
            const data = await response.json();

            let layout = defaultLayout;

            if (data.layout_config) {
                // Merge saved config with content templates
                layout = data.layout_config.map(item => {
                    const tplId = `tpl-${item.id}`;
                    const tpl = document.getElementById(tplId);
                    return {
                        ...item,
                        content: tpl ? tpl.innerHTML : ''
                    };
                });
            }

            grid.load(layout);

        } catch (error) {
            console.error('Error loading layout:', error);
            grid.load(defaultLayout);
        }
    }

    async function saveLayout() {
        const layout = grid.save(false); // false = don't save content, just structure
        // Map back to simple IDs for storage
        const simplifiedLayout = layout.map(item => ({
            x: item.x,
            y: item.y,
            w: item.w,
            h: item.h,
            id: item.id || item.el.querySelector('.widget').dataset.widgetType
        }));

        try {
            const response = await fetch('/api/dashboard/layout', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: 'My Layout',
                    layout_config: simplifiedLayout
                })
            });

            if (response.ok) {
                // Show success feedback
                const btn = document.querySelector('button[onclick="saveLayout()"]');
                const originalText = btn.innerHTML;
                btn.innerHTML = '<i class="fas fa-check"></i> Saved!';
                setTimeout(() => btn.innerHTML = originalText, 2000);
            }
        } catch (error) {
            console.error('Error saving layout:', error);
            alert('Failed to save layout');
        }
    }

    function resetLayout() {
        if (confirm('Reset to default layout?')) {
            grid.removeAll();
            grid.load(defaultLayout);
            // Re-init charts as DOM elements were recreated
            setTimeout(initCharts, 100);
        }
    }

    function initCharts() {
        // CPU Chart
        const cpuCanvas = document.getElementById('cpu-widget-chart');
        if (cpuCanvas) {
            if (cpuChart) cpuChart.destroy();
            cpuChart = new Chart(cpuCanvas, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'CPU %',
                        data: cpuData,
                        borderColor: 'rgba(56, 189, 248, 1)',
                        backgroundColor: 'rgba(56, 189, 248, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { beginAtZero: true, max: 100, ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                        x: { display: false }
                    }
                }
            });
        }
        // Memory Chart
        const memCanvas = document.getElementById('memory-widget-chart');
        if (memCanvas) {
            if (memoryChart) memoryChart.destroy();
            memoryChart = new Chart(memCanvas, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Memory %',
                        data: memoryData,
                        borderColor: 'rgba(168, 85, 247, 1)',
                        backgroundColor: 'rgba(168, 85, 247, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { beginAtZero: true, max: 100, ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                        x: { display: false }
                    }
                }
            });
        }
        // Network Chart
        const netCanvas = document.getElementById('network-widget-chart');
        if (netCanvas) {
            if (networkChart) networkChart.destroy();
            networkChart = new Chart(netCanvas, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Network Sent (bytes)',
                        data: networkData,
                        borderColor: 'rgba(255, 99, 132, 1)',
                        backgroundColor: 'rgba(255, 99, 132, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { beginAtZero: true, ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                        x: { display: false }
                    }
                }
            });
        }

    }

    // Server selection
    const serverSelect = document.getElementById('serverSelect');
    if (serverSelect) {
        serverSelect.addEventListener('change', (e) => {
            currentServerId = parseInt(e.target.value);
            updateMetrics();
        });
    }

    // Fetch and update metrics
    async function updateMetrics() {
        try {
            const url = currentServerId ? `/api/metrics?server_id=${currentServerId}` : '/api/metrics';
            const response = await fetch(url);
            const data = await response.json();

            // Update CPU
            updateText('cpu-widget-percent', data.cpu.percent.toFixed(1));
            updateText('cpu-widget-freq', data.cpu.freq);
            if (data.cpu.temp_c) {
                updateText('cpu-widget-temp', `${data.cpu.temp_c.toFixed(1)}°C / ${data.cpu.temp_f.toFixed(1)}°F`);
            }

            // Update Memory
            updateText('memory-widget-percent', data.memory.percent.toFixed(1));
            updateText('memory-widget-used', data.memory.used);
            updateText('memory-widget-total', data.memory.total);

            // Update Network
            if (data.network) {
                updateText('network-widget-sent', data.network.bytes_sent);
                updateText('network-widget-recv', data.network.bytes_recv);
                // Push to network chart data
                networkData.push(data.network.bytes_sent_raw);
            }
            if (data.connections) {
                updateText('network-widget-connections', data.connections.total);
                updateText('network-widget-established', data.connections.established);
            }

            // Update Disk I/O
            updateText('io-widget-read', data.io.read_bytes);
            updateText('io-widget-write', data.io.write_bytes);
            updateText('io-widget-read-count', `${data.io.read_count.toLocaleString()} ops`);
            updateText('io-widget-write-count', `${data.io.write_count.toLocaleString()} ops`);

            // Update Disk Usage
            const diskList = document.getElementById('disk-widget-list');
            if (diskList) {
                diskList.innerHTML = '';
                data.disk.forEach(disk => {
                    const diskItem = document.createElement('div');
                    diskItem.className = 'disk-item';
                    diskItem.innerHTML = `
                        <div class="disk-header">
                            <span><strong>${disk.device}</strong> (${disk.mountpoint})</span>
                            <span>${disk.used} / ${disk.total} (${disk.percent.toFixed(1)}%)</span>
                        </div>
                        <div class="disk-bar-bg">
                            <div class="disk-bar-fill" style="width: ${disk.percent}%"></div>
                        </div>
                    `;
                    diskList.appendChild(diskItem);
                });
            }

            // Update charts
            const now = new Date().toLocaleTimeString();
            labels.push(now);
            cpuData.push(data.cpu.percent);
            memoryData.push(data.memory.percent);

            if (labels.length > maxDataPoints) {
                labels.shift();
                cpuData.shift();
                memoryData.shift();
                networkData.shift();
            }

            if (cpuChart) cpuChart.update('none');
            if (memoryChart) memoryChart.update('none');
            if (networkChart) networkChart.update('none');
        } catch (error) {
            console.error('Error fetching metrics:', error);
        }
    }

    function updateText(id, value) {
        const el = document.getElementById(id);
        if (el) el.textContent = value;
    }

    // Network Connection Details Modal
    async function showConnectionDetails(status) {
        try {
            const url = status === 'all'
                ? '/api/network/connections'
                : `/api/network/connections?status=${status}`;

            const response = await fetch(url);
            const data = await response.json();

            if (data.error) {
                alert(`Error: ${data.error}`);
                return;
            }

            // Populate modal with connection data
            const tableBody = document.getElementById('connection-table-body');
            tableBody.innerHTML = '';

            if (data.connections.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: var(--text-secondary);">No connections found</td></tr>';
            } else {
                data.connections.forEach(conn => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${conn.protocol}</td>
                        <td>${conn.local_address}</td>
                        <td>${conn.remote_address}</td>
                        <td><span class="status-badge status-${conn.status.toLowerCase()}">${conn.status}</span></td>
                        <td>${conn.pid}</td>
                        <td>${conn.process}</td>
                    `;
                    tableBody.appendChild(row);
                });
            }

            // Update modal title
            const modalTitle = document.getElementById('connection-modal-title');
            modalTitle.textContent = status === 'all'
                ? `All Network Connections (${data.count})`
                : `Established Connections (${data.count})`;

            // Show modal
            document.getElementById('connection-modal').style.display = 'flex';
        } catch (error) {
            console.error('Error fetching connection details:', error);
            alert('Failed to fetch connection details');
        }
    }

    function closeConnectionModal() {
        document.getElementById('connection-modal').style.display = 'none';
    }

    // Close modal when clicking outside
    document.addEventListener('DOMContentLoaded', function () {
        const modal = document.getElementById('connection-modal');
        if (modal) {
            modal.addEventListener('click', function (e) {
                if (e.target === modal) {
                    closeConnectionModal();
                }
            });
        }
    });

</script>
{% endblock %}